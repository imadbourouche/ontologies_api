#!/usr/bin/env bash

# Function to display script usage information
show_help() {
  echo "Usage: $0 {dev|test|run|help} [--reset-cache] [--api-url API_URL] [--api-key API_KEY] [--old-path OLD_PATH] [--goo-path GOO_PATH] [--sparql-client-path SPARQL_CLIENT_PATH]"
  echo "  dev            : Start the Ontoportal API development server."
  echo "                  Example: $0 dev --api-url http://localhost:9393"
  echo "                  Use --reset-cache to remove volumes: $0 dev --reset-cache"
  echo "  test           : Run tests."
  echo "  run            : Run a command in the Ontoportal API Docker container."
  echo "  help           : Show this help message."
  echo
  echo "Description:"
  echo "  This script provides convenient commands for managing an Ontoportal API"
  echo "  application using Docker Compose. It includes options for starting the development server,"
  echo "  running tests, and executing commands within the Ontoportal API Docker container."
  echo
  echo "Options:"
  echo "  --reset-cache             : Remove Docker volumes (used with 'dev')."
  echo "  --api-url API_URL         : Specify the API URL."
  echo "  --api-key API_KEY         : Specify the API key."
  echo "  --old-path OLD_PATH       : Specify the path for ontologies_linked_data."
  echo "  --goo-path GOO_PATH       : Specify the path for goo."
  echo "  --sparql-client-path SPARQL_CLIENT_PATH : Specify the path for sparql-client."
  echo
  echo "Goals:"
  echo "  - Simplify common tasks related to Ontoportal API development using Docker."
  echo "  - Provide a consistent and easy-to-use interface for common actions."
}

# Function to update or create the .env file with API_URL and API_KEY
update_env_file() {
  local api_url="$1"
  local old_path="$2"
  local goo_path="$3"
  local sparql_client_path="$4"

  # Update  the .env file with the provided values
  file_content=$(<.env)

  # Make changes to the variable
  while IFS= read -r line; do
        if [[ "$line" == "API_URL="* ]]; then
          echo "API_URL=$api_url"
        elif [[ "$line" == "ONTOLOGIES_LINKED_DATA_PATH="* ]]; then
          echo "ONTOLOGIES_LINKED_DATA_PATH=$old_path"
        elif [[ "$line" == "GOO_PATH="* ]]; then
          echo "ONTOLOGIES_LINKED_DATA_PATH=$goo_path"
        elif [[ "$line" == "SPARQL_CLIENT_PATH="* ]]; then
          echo "SPARQL_CLIENT_PATH=$sparql_client_path"
        else
          echo "$line"
        fi
  done <<< "$file_content" > .env
}

# Function to create configuration files if they don't exist
create_config_files() {
  if [ ! -f ".env" ]; then
      echo "Creating .env file from env.sample"
      cp .env.sample .env
  fi

  if [ ! -f "config/environments/development.rb" ]; then
    echo "Creating config/environments/development.rb file from config/environments/config.rb.sample"
    cp config/bioportal_config_env.rb.sample config/bioportal_config_development.rb
  fi
}

# Function to build Docker run command with conditionally added bind mounts
build_docker_run_cmd() {
  local custom_command="$1"
  local old_path="$2"
  local goo_path="$3"
  local sparql_client_path="$4"

  local docker_run_cmd="docker run --rm -it"
  local bash_cmd=""

  # Conditionally add bind mounts only if the paths are not empty
  for path_var in "old_path:ontologies_linked_data" "goo_path:goo" "sparql_client_path:sparql-client"; do
    IFS=':' read -r path value <<< "$path_var"
    if [ -n "${!path}" ]; then
      echo "Run: bundle config local.$value ${!path}"
      docker_run_cmd+=" -v ${!path}:/app/$value"
      bash_cmd+="(bundle config local.$value /app/$value) &&"
    else
      bash_cmd+="(bundle config unset local.$value) &&"
    fi
  done

  bash_cmd+="(bundle check || bundle install) && $custom_command"
  docker_run_cmd+=" --service-ports api bash -c \"$bash_cmd\""
  eval "$docker_run_cmd"
}

# Function to handle the "dev" and "test" options
run_command() {
  local custom_command="$1"
  local reset_cache=false
  local api_url=""
  local old_path=""
  local goo_path=""
  local sparql_client_path=""


  # Check for command line arguments
  while [[ "$#" -gt 0 ]]; do
    case $1 in
      --reset-cache)
        reset_cache=true
        shift
        ;;
      --api-url)
        api_url="$2"
        shift 2
        ;;
      --old-path)
        old_path="$2"
        shift 2
        ;;
      --goo-path)
        goo_path="$2"
        shift 2
        ;;
      --sparql-client-path)
        sparql_client_path="$2"
        shift 2
        ;;
      *)
        echo "Unknown option: $1"
        show_help
        exit 1
        ;;
    esac
  done


  # Check if --reset-cache is present and execute docker compose down --volumes
  if [ "$reset_cache" = true ]; then
    echo "Resetting cache. Running: docker compose down --volumes"
    docker compose down --volumes
  fi

  # Display the updated environment variables
  update_env_file "$api_url" "$old_path" "$goo_path" "$sparql_client_path"

  # Build the Docker run command
  echo "Run: $custom_command"
  build_docker_run_cmd "$custom_command" "$old_path" "$goo_path" "$sparql_client_path"
}

# Function to handle the "dev" option
dev() {
  echo "Starting OntoPortal API development server..."

  local custom_command="bundle exec api s -b 0.0.0.0 -p 3000"
  run_command "$custom_command"
}
# Function to handle the "test" option
test() {
  echo "Running tests..."

  local custom_command="API_URL=$api_url bundle exec rake test TEST=\"$test_path\" TESTOPTS=\"$test_options\""
  run_command "$custom_command"
}

# Function to handle the "run" option
run() {
  echo "Run: $*"
  docker compose run --rm -it api bash -c "$*"
}

create_config_files
# Main script logic
case "$1" in
  "run")
    run "${@:2}"
    ;;
  "dev")
    dev "${@:2}"
    ;;
  "test")
    test "${@:2}"
    ;;
  "help")
    show_help
    ;;
  *)
    show_help
    exit 1
    ;;
esac
